# JewGo Production Deployment with Ngrok

This guide explains how to create a one-time production deployment of the JewGo system using ngrok for external access.

## Overview

The ngrok deployment creates a complete production environment with:
- **Frontend**: Next.js application
- **Backend**: Flask API with Gunicorn
- **Database**: PostgreSQL
- **Cache**: Redis
- **Tunnels**: ngrok for external access

## Prerequisites

### Required Software
- Docker and Docker Compose
- ngrok CLI
- curl (for health checks)
- jq (for parsing ngrok responses)

### ngrok Setup
1. Sign up for a free ngrok account at https://ngrok.com
2. Get your authtoken from https://dashboard.ngrok.com/get-started/your-authtoken
3. Install ngrok:
   ```bash
   # macOS
   brew install ngrok/ngrok/ngrok
   
   # Linux
   curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
   echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
   sudo apt update && sudo apt install ngrok
   ```
4. Authenticate ngrok:
   ```bash
   ngrok authtoken YOUR_TOKEN_HERE
   ```

## Quick Deployment

### Option 1: Quick Deploy (Recommended)
```bash
# Run the quick deployment script
./scripts/quick-ngrok-deploy.sh
```

This script will:
- Check prerequisites
- Set up production environment files
- Build and start all services
- Provide ngrok URLs for external access

### Option 2: Full Deploy
```bash
# Run the comprehensive deployment script
./scripts/production-ngrok-deploy.sh
```

This script includes additional features:
- More detailed health checks
- Better error handling
- Comprehensive logging
- Automatic cleanup on exit

## Deployment Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   ngrok.io      │    │   ngrok.io      │    │   Local Access  │
│   (Frontend)    │    │   (Backend)     │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  ngrok-frontend │    │  ngrok-backend  │    │   localhost     │
│   (Port 4040)   │    │   (Port 4041)   │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│    Frontend     │    │     Backend     │    │   PostgreSQL    │
│   (Port 3000)   │    │   (Port 8081)   │    │   (Port 5432)   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                                 ▼
                        ┌─────────────────┐
                        │      Redis      │
                        │   (Port 6379)   │
                        └─────────────────┘
```

## Services

### Frontend (Next.js)
- **Port**: 3000
- **Build**: Optimized production build
- **Environment**: Production configuration
- **Health Check**: HTTP endpoint

### Backend (Flask + Gunicorn)
- **Port**: 8081
- **Server**: Gunicorn with production settings
- **Environment**: Production configuration
- **Health Check**: `/health` endpoint

### Database (PostgreSQL)
- **Port**: 5432
- **Database**: jewgo
- **User**: jewgo_user
- **Password**: jewgo_password
- **Health Check**: pg_isready

### Cache (Redis)
- **Port**: 6379
- **Health Check**: redis-cli ping

### Ngrok Tunnels
- **Frontend Tunnel**: Port 4040
- **Backend Tunnel**: Port 4041
- **Public URLs**: Automatically generated

## Environment Configuration

### Backend Environment
```bash
FLASK_ENV=production
FLASK_SECRET_KEY=<auto-generated>
DATABASE_URL=postgresql://jewgo_user:jewgo_password@postgres:5432/jewgo
REDIS_URL=redis://redis:6379
CORS_ORIGINS=https://*.ngrok.io,https://*.ngrok-free.app,http://localhost:3000
JWT_SECRET_KEY=<auto-generated>
LOG_LEVEL=INFO
PORT=8081
ENVIRONMENT=production
```

### Frontend Environment
```bash
NODE_ENV=production
NEXT_PUBLIC_API_URL=http://backend:8081
NEXT_PUBLIC_BACKEND_URL=http://backend:8081
NEXT_PUBLIC_URL=http://localhost:3000
DATABASE_URL=postgresql://jewgo_user:jewgo_password@postgres:5432/jewgo
NEXTAUTH_SECRET=<auto-generated>
NEXTAUTH_URL=http://localhost:3000
```

## Monitoring and Management

### View Logs
```bash
# All services
docker-compose -f docker-compose.ngrok.yml logs -f

# Specific service
docker-compose -f docker-compose.ngrok.yml logs -f backend
docker-compose -f docker-compose.ngrok.yml logs -f frontend
```

### Health Checks
```bash
# Backend health
curl http://localhost:8081/health

# Frontend health
curl http://localhost:3000

# Database health
docker-compose -f docker-compose.ngrok.yml exec postgres pg_isready -U jewgo_user -d jewgo

# Redis health
docker-compose -f docker-compose.ngrok.yml exec redis redis-cli ping
```

### Ngrok Monitoring
- **Frontend Tunnel**: http://localhost:4040
- **Backend Tunnel**: http://localhost:4041

## Stopping the Deployment

### Quick Stop
```bash
./scripts/stop-ngrok-deploy.sh
```

### Manual Stop
```bash
# Stop all services
docker-compose -f docker-compose.ngrok.yml down --volumes --remove-orphans

# Clean up environment files
rm -f config/environment/backend.production.env
rm -f config/environment/frontend.production.env
rm -f docker-compose.ngrok.yml
```

## Troubleshooting

### Common Issues

#### 1. Port Conflicts
If ports are already in use:
```bash
# Check what's using the ports
lsof -i :3000
lsof -i :8081
lsof -i :5432
lsof -i :6379

# Stop conflicting services
sudo kill -9 <PID>
```

#### 2. ngrok Authentication Issues
```bash
# Check ngrok config
ngrok config check

# Re-authenticate
ngrok authtoken YOUR_TOKEN
```

#### 3. Docker Build Issues
```bash
# Clean Docker cache
docker system prune -a

# Rebuild without cache
docker-compose -f docker-compose.ngrok.yml build --no-cache
```

#### 4. Service Health Check Failures
```bash
# Check service logs
docker-compose -f docker-compose.ngrok.yml logs backend
docker-compose -f docker-compose.ngrok.yml logs frontend

# Restart specific service
docker-compose -f docker-compose.ngrok.yml restart backend
```

### Debug Mode
For debugging, you can run services in development mode:
```bash
# Use optimized docker-compose
docker-compose -f docker-compose.optimized.yml up -d

# Check logs
docker-compose -f docker-compose.optimized.yml logs -f
```

## Security Considerations

### Production Deployment
- This is a **production deployment** with real data
- Keep ngrok URLs secure and don't share publicly
- Monitor logs for any security issues
- Use strong passwords in production

### Environment Variables
- All secrets are auto-generated for this deployment
- In real production, use proper secret management
- Never commit environment files with real secrets

### Network Security
- ngrok tunnels are public - be aware of this
- Consider using ngrok's authentication features
- Monitor access logs regularly

## Performance Optimization

### Docker Optimizations
- Images are built with BuildKit for faster builds
- Multi-stage builds for smaller images
- Health checks for better reliability

### Application Optimizations
- Gunicorn with optimized worker configuration
- Redis caching for better performance
- Production-grade logging

## Backup and Recovery

### Database Backup
```bash
# Create backup
docker-compose -f docker-compose.ngrok.yml exec postgres pg_dump -U jewgo_user jewgo > backup.sql

# Restore backup
docker-compose -f docker-compose.ngrok.yml exec -T postgres psql -U jewgo_user jewgo < backup.sql
```

### Volume Backup
```bash
# Backup PostgreSQL data
docker run --rm -v jewgo_app_postgres_data:/data -v $(pwd):/backup alpine tar czf /backup/postgres_backup.tar.gz -C /data .

# Restore PostgreSQL data
docker run --rm -v jewgo_app_postgres_data:/data -v $(pwd):/backup alpine tar xzf /backup/postgres_backup.tar.gz -C /data
```

## Support

For issues with this deployment:
1. Check the troubleshooting section above
2. Review service logs
3. Verify all prerequisites are met
4. Ensure ngrok is properly configured

## Next Steps

After successful deployment:
1. Test all functionality through ngrok URLs
2. Monitor performance and logs
3. Set up proper monitoring and alerting
4. Plan for production deployment on a proper hosting platform
